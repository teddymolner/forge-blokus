In our project, we decided to model a simplified version of Blokus, the turn-based tile board game. We started with generating all types of 3x3 blocks, ranging from something as simple as a 1x1 cube, to as complex as a 7-square U. From there, we expanded the model to implement statefulness, allowing multiple pieces to be placed on the board at a time. Our goal here was to encode this transition state where there are no overlaps between pieces, and we can have different pieces fitting together. These steps served as a bridge to getting a fully working blokus game done for our final project.

For our signatures, we decided to split into two files, one (blokus.frg) to represent the one block case and the other (blokus_state.frg) for our transition states. In the one block case, we have a board specified by a partial function from a coordinate to a placement. We define a placement to be a shape and the anchor (coord) on the board where that shape is located. A shape is defined as a series of offsets, where an offset is a (local) position connected to a next offset. This constrains all offsets to be within a local 3x3 grid, and the anchor point allows us to place the shape anywhere and translate the coordinates as desired.

Running the blokus.frg file should open up our visualizer with a 3x3 shape of size specified in the run command at the bottom of the file (currently set at 7). Running the blokus_state.frg file will show 3 or more states, one of which is the inital state, and the other two represent placing one shape and then placing another shape, keeping the first shape static. Any more states represent the addition of more shapes to the model, though this hurts performance. We created a custom visualization using help from ChatGPT which makes the output readable, as the tabular form is not at all helpful in this project.

We made some key design choices as we went progressed through the model. Notably, one of these was switching from a partial function specifying the offset values of a shape (similar to how the queens are specified in the n-queens lab), to the linear progression with each offset having a next value. We did this in order to utilize the reachable predicate within wellformed, as it made a lot of the logic more streamlined and clear.

Another design choice was in how we decided to model the transition states. Since performance was a huge concern throughout the development of our project, we often had to write less constrained predicates that allowed more in order to keep our performance reasonable. This limited the scope of what we could do with our model, and perhaps expanding into relational forge would have allowed us to have better performance.

Our predicates are overall standard with most transition models, with both a wellformed and wellformedState predicate ruling out degenerate cases. For our transition states, we have an init predicate to specify an empty board, and then a step predicate with the Guard, Action, and Frame structure. We have some helpful predicates like inShape and coveredByPlacement which iterate through a shape (using reachable with next) to avoid repeated work. These helper predicates are used within wellformed and wellformedState. We then fit together wellformed and wellformedState when running to get our sample game.
